Integration Level
Next comes the integration testing. The concept is simple. We tested units separately, now we start connecting them and making sure nothing blows up. Testing two units is integration testing. Testing three or four units together is also integration testing. It just means a bigger integration test, but still an integration test. 

If you have a typical threeâ€‘layer system, UI, also called the front end, the back end, where most of the logic lives, and the database. 

If you execute a test that uses all three of these layers, we could call that an integration test, too. So remember that working with two or more boxes across two or more layers automatically means you're doing some kind of integration testing. The way I presented the idea is more of a tester's perspective. If you ask a developer, however, they will probably have a different or an additional definition of integration testing. 

Since they work with code at the lowest levels, writing automated tests that verify communication between two or three source files will be considered an integration test by them. If a test needs to fetch a single file in the file system, even that will qualify the test as an integration one. The developer's perspective on unit and integration testing is explored quite well in Unit Testing Principles, Practices, and Patterns book, and I recommend it for two reasons. If you have some programming basics, you will understand the developer's perspective on testing levels. And second, you will realize that ISTQB test level definitions are not universal in the industry. I must highlight that this book is not necessary for the exam. The material in this book goes quite beyond that. But for the exam, just remember that integration testing means verifying that two or more units work correctly together, regardless of how you define the word unit.

### Integration Level Subtypes
The ISTQB syllabus recognizes two specific subcategories of integration testing, component integration and system integration. Component integration is what we already discussed. You have a system, you have many components, you test that they integrate with each other without issues. That's within a single system wherever you draw the border of that system. 
On the other hand, system integration testing focuses on interactions between systems. Our fictional bank doesn't exist in isolation. It needs to communicate and exchange data with other banks, with credit card companies, and dozens of other vendors. Each of them has their own system with a public interface, the endpoints through which these systems communicate. Given this rather broad definition of integration testing, it's not a surprise that both the test object and the test basis can be just about anything. Entire subsystems, databases, infrastructure components, interfaces, and microservices are all examples of test objects. And you can use any documentation related to these objects as a test basis for your test scenarios, technical spec, design documents, sequence diagrams, and public interface definitions. When it comes to the test approach, it's a real mix. Frequently, both developers and testers participate in integration testing, and it will vary quite a lot depending on where you work, and it depends on many factors. For example, a strong technical background is required to carry out such testing in some projects, and it just so happens that the testers don't have it. So the developers mostly do the integration testing. That was the case in my previous job, for example. The situation is quite different in my current team and project. We have enough test automation engineers that are capable to carry out all sorts of independent technical integration testing, and we support manual testers who focus on system and acceptance testing. Let's talk about these now.

### System Level
In a way, system testing is a bit like full integration testing of all modules. You would expect all pieces to be put together, and instead of testing various combinations of subsections of the same system, you take a step back and focus on the behavior of the system as a whole. Two things to consider when you do system testing. Your starting point is typically not within the system, as is the case with integration testing, but rather outside. Whatever public interfaces the system has, imagine like the outside doors or windows of a house, and you interact with the system only through these interfaces or endpoints, as if you didn't know about the internal mechanics. If you were testing a car, then integration testing would be like looking at the car internals and make sure that the engine fits and works well with the rest of the car. Whereas system level testing is more similar to just taking it for a test drive without knowing or caring anything about what happens inside. The public interface to you, in this case, is the steering wheel, the seat, the pedals, and the gearbox. As long as you can drive around without problems, then the system works fine. The second thing to consider are the system's paths and flows. If you are making a payment to a different account, that is one flow. If you are getting a mortgage, that's another flow. If you are buying some package deal that involves several financial products with a special discount, that's a third flow, which is a combination of the first two. As you might imagine, a complex system has hundreds or even thousands of such paths and flows, and it takes quite a bit of experience and knowledge to figure out how you can cover as much as sensibly possible in the little time you have.

