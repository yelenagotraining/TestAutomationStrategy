Intro:
This presentation is broken down into four major parts.

 First, we'll define and explore different software development lifecycle models. It's important to know these models because they hugely influence the life and work of a tester.
 
  Then we'll look at different test levels. You see, any nontrivial piece of software can be viewed as a stack or a network of subsystems or modules and there is a different way to test each layer, so it's really useful to know that.
  
   Next, we'll define and explore different test types, such as functional and nonfunctional ones. If understanding test levels is like learning to see in 2D, then learning about the test types is like adding a dimension to your vision. You'll see the world of testing in 3D. 
   
   Last, but not least, we'll see what maintenance testing is all about, what it is triggered by, and the role of impact analysis on it. 
   
    So in this module we'll define the SDLC, we'll talk about why it is important to have one, we'll learn the two broad categories defined by ISTQB, and of course, the models themselves, such as Waterfall, the V‑Model, Scrum, and others. As we explore them, we'll discuss their advantages and disadvantages, as well as their effect on testing. So let's get started.


SDLC. Every modern software team uses one, but what is it, actually, and why do we need one at all? Let's start with a simple definition. SDLC is a systematic plan that defines a process and the what, who, when, and how to deliver software in an organized and efficient way. Systematic plan is key here. Whenever you have a complex undertaking involving many people and you want to achieve a common goal, you need to set up rules. You can't have a bunch of uncoordinated people do their own thing and hope it all turns out well in the end. It's going to be a mess. So to elaborate, a lifecycle model offers a basis for project planning and control, helps every team player know their role, what they are supposed to do and when. This in turn ensures smooth progress and increases development speed. And if you have smooth progress, then you keep costs low. These are the benefits, at least in theory. Do all models provide equal benefits? You can probably guess that, no, not all lifecycle models are created equal. Some are better, some are worse, some are more appropriate to a specific context and project, some are less. I've provided you with my own simple definition of the SDLC to give you a foundational understanding, but now I'd like to give you the one given in the official ISTQB® material, and we'll be using that as a basis for the rest of the module. SDLC is a model that describes the types of activity performed at each stage in a software development project and how the activities relate to one another logically and chronologically. Let's highlight the keywords. Model. As I said, many different models exist, but any one of them must answer the main question, how, how to organize everyone to build software? Activity. Who does what? Stage. We should understand the different stages of any model, where you fit as a team member. And I would also like to highlight chronologically, when things get done. This is probably the main differentiator between the models, as you'll see in just a moment

### SDLC Categories

ISTQB groups the models into two broad categories, sequential and iterative. The classic sequential models are Waterfall and the V‑Model, 

whereas examples of iterative models include Rational Unified Process, Scrum, Kanban, and Spiral. 

That may seem like a lot, but don't worry. They are not that fundamentally different.

 In fact, they can be rather similar, and they differ mostly on how things are done in the context of time. But regardless of what model you participate in, it will recognize the same basic building blocks, requirement analysis, design, development, also known as implementation or simply coding, testing, deployment or delivery, and, in most cases, maintenance.

 ### Waterfall SDLC Model

 
A sequential development model describes the software development process as a linear sequential flow of activities. This means that any phase should begin when the previous phase is complete, and thus the waterfall model is born. Suppose you have to deliver a piece of software that has 10 big different features. With the waterfall model, business analysts do all of the analysis first, then developers and architects do all of the design to the last detail. Once that is done, they do all of the coding. They implement all 10 features. This gets delivered to testers as version 1.0. The testers do the testing. They might find and report some bugs. Developers fix them and deliver the next version 1.1. This can go back and forth until, say, version 1.5, then deliver to the customer, and then over time do minor maintenance and updates as the situation requires. So even a strictly sequential model has some iterative actions, but it is kept to a minimum. Sounds simple, right? Well, simplicity is arguably the main advantage of this model. It's easy to understand in theory, In practice, however many things can go wrong, and the cost is really high. Depending on how you manage it, the entire process can be slow and inefficient, where many people wait for others to finish. If business analysts are taking too long to write up and deliver the requirements, then developers and testers sit around idle doing nothing. While developers are writing code, testers are still sitting doing nothing. Yes, of course, testers can and should prepare tests in advance to keep themselves busy, but it usually doesn't take as long as actual development, so there's still a long period of idleness. There's another disadvantage. Any phase can become a bottleneck. If we come back to our previous example, then if developers are delaying because they are facing unexpected challenges, which is frequently the case, then testers have even more time to do nothing. Another extremely important factor is very late feedback, and I talked about it in the other ISTQB® course on testing fundamentals. There's always a chance that a mistake has been made very early in the process, let's say, an illogical or a contradictory requirement. That mistake then gets built into the software and it is discovered only several stages later in testing. This means a lot of rework, and that's not good. The sooner you discover an issue, the better. There is one more downside, which ISTQB® syllabus doesn't mention, but I would like to highlight, nevertheless, because it's part of real life and it's additional pressure on testers. Because here's what happens. Imagine a waterfall project that is supposed to last 4 months. Business analysts have 1 month to produce complete requirements, developers have 2 months to design and implement, and the last month is for testers to find and report bugs and developers to fix them. After that, we should deliver the software. Guess what? Things take longer than planned, and so you now have 1 week instead of 4. The amount of work is the same, but you have to somehow accomplish it four times faster. Testers might ask to extend the deadline because it's too much work in too little time, but the answer to that is usually a big no. And it's not uncommon then for testers being viewed as the bottleneck and the ones holding up the release. Of course, if you miss any bugs, that's also your fault. This is a bad scenario, but it's far from being the only one. Better models exist and followed, so let's see how your testing life looks like in the V‑model.

V-Model

The V‑model integrates the test process throughout the development process, implementing the principle of early testing. This is a significant improvement. How exactly does it include testing? By showing the test levels associated with each corresponding development phase. Examples of test levels include component and integration testing, and one is typically done after the other, but we'll explore this in detail in the next module. So waterfall is like seeing things in one horizontal dimension. Things just progress chronologically from left to right, any kind of testing is almost at the very end, and there is no depth. With this kind of vision, the software, or the entire system, is just one big black box that needs to be tested. On the other hand, the V‑model has the same sequence, from requirements and design to development and testing, but and it's an important but, it adds a second vertical dimension to our vision. It adds depth to the process, and it includes different kinds of testing throughout the lifecycle. Not only that, we can see that testing starts earlier. It will probably come as no surprise to you that every level has a different basis for the test cases.

### Iterative SDLCs

Iterative, also called incremental development, means that you do the usual activities, requirement analysis, design, implementation, and testing, but you do that in small pieces. 

Remember our example from the previous clip, a piece of software that is supposed to have 10 features, and with sequential models, you would design all 10, implement all 10, test all 10. In contrast with an incremental approach, you would deliver one feature at a time, or perhaps two features at a time, up to project management to decide, let's say two. The team then creates the requirements for the two features, architects design them, developers develop them, testers test them. And here's the thing. While people on the right side of the lifecycle are busy with their primary tasks, the people on the left side don't sit idle. They start working on the next two features, and so this becomes a bit like a conveyor belt. But instead of car parts, you assemble software with everyone busy with something. This example focuses on breaking up the work into features, but more frequently, the work is broken up by time cycles, often of fixed duration, typically either 2 weeks or a month. This means that the team has to estimate and ask itself, what can we achieve in the next 2 weeks? These two small features? Okay, let's do those. That gets built, tested, and delivered. Okay, what can we do in the next 2 weeks? Just this one feature, because it's pretty big? Okay, we build and deliver that, and so on. So I hope you can now see the main difference between the two groups. A sequential model really means that we do one major activity at a time, whereas with iterative models you do a bit of everything within a fixed time frame. Consequently, this means that incremental models may deliver something usable very fast but with limited functionality. To deliver the entire functionality, it all adds up to months or even years. Okay, but what kind of iterative models do we have? Quite a few more than sequential ones, actually. To name just the most popular ones, Rational Unified Process; agile, which is an umbrella term for several models such as Scrum and kanban, Kanban is my personal favorite; and finally spiral. Explaining each one of them is outside the scope of this video, so let me just give you a very high‑level explanation of how they are different. With Rational Unified Process, your iterations are relatively long, 2 to 3 months, and so you typically deliver groups of interrelated features. With Scrum, the iterations are shorter, typically 2 weeks, but can be even shorter. This of course means that fewer things get delivered per each iteration, sometimes not even any new features, just bug fixes and enhancements for the previously delivered functionality. Additionally, you have assigned roles, and tasks have assigned owners. Kanban is a more relaxed version of Scrum. Roles are fluid, so it naturally has a flat hierarchy, tasks are typically shared by everyone, you don't have a single coordinator distributing things, and timelines evolve on an as‑needed basis. A great model, but in my opinion works only for highly self‑organized and self‑motivated teams. Finally, the spiral model involves creating experimental increments, some of which may be heavily reworked or even abandoned later. In other words, is the most flexible model that allows you to integrate a bit of everything from other models. Personally, I haven't worked with this model, so I don't know what it's like, but it's useful to know that it exists. If you want a deep dive and learn a specific model such as Scrum, then look no further than Pluralsight. It offers entire paths on it. If you want to know more about agile and Scrum, it is enough to do a quick search on the site and you'll find dozens of courses.

Which SDLC Is the Best?
Enough talk about the different models. Let's hear which one is the best. That's such a frequent question, isn't it? Which tool is the best? Which programming language is the best? Which testing lifecycle model is the best? And I'm sure you know that the answer is the same to all of them. It depends. Yes, it may be frustrating, but it's true, and that's life. Things are never that simple. The very first thing to bear in mind is that no matter which model you choose, be it Waterfall or Scrum, they are all a simplification of reality and not a precise description of how the work actually proceeds. And this leads us to the second major point. Iterative models are not always better than sequential ones. Yes, the waterfall model in its most simplistic form where no testing is done until very late in the project is probably archaic and inadequate by now. One can certainly make the case, but as always, context matters, and sometimes a robust, well thought out sequential model may be good and simple enough to get the job done. Additionally, the lifecycle models themselves may be combined within a single project or organization, not just tweaked and adjusted. For example, a V‑Model may be used for the development and testing of the back end systems and their integrations while a Scrum development model may be used to develop and test the front end user interface and functionality. Mixing models is indeed entirely possible in practice. I know it because we do just that in my current job. The developers practice Scrum; however, our team of testers and test automation engineers uses a simplified version of Scrum to the point that it's already closer to Kanban. As long as work gets done on time and teams interoperate smoothly, I don't see why that can be an issue.

Main Takeaways
Let's quickly sum up this module. We now know what the SDLC stands for and that different models of the lifecycle exist. You are likely to experience working in multiple models throughout your career. And whichever it is, it will definitely affect your workflow as a tester. Two broad categories exist, sequential models such as waterfall and the V‑Model. Everything is planned, then everything is designed, then implemented and tested before delivery. The V‑Model allows for various types and levels of testing and promotes one of the seven principles. Testing early saves time and money. With iterative and incremental models, you do the same activities as in waterfall and V‑Models, but you do a bit of everything within a time boxed period of several weeks or months to deliver a subset of the entire functionality, and you keep doing that until you deliver everything. Examples of such models include Rational Unified Process, Scrum, Kanban, and Spiral. As we talked about the V‑Model, we had to mention the so‑called test levels. Unless you have extensive experience in software development in any capacity, these terms probably seem abstract right now. So let's take a deep dive into what they are and what they involve in the next module.

Discovering Test Levels
In this section, we will be discovering the various test levels.

 Most modern nontrivial software is not a single monolith black box behind a screen where all the code is written in one huge file. Software can often be broken down into multiple layers and then those layers into smaller modules.

 And those modules, in turn, consist of files with code that actually runs and executable whatever it is supposed to do. 
 
 And today, building software and especially entire enterprise architectures is often similar to assembling a jigsaw puzzle. Developers create small jigsaw pieces. Then they gradually assemble them together until it all works. And this is the basic idea behind test levels. You can test big and small. The development team together with testers can test the smaller units or components independently, then how they interact together, first two units, then three units, then all units as a whole. The ISTQB® Foundation syllabus lists four levels, component, integration, system, and acceptance levels. Each of these levels has specific objectives and approaches, as well as types of typical defects found at every level, and we'll discuss these as we go along. We will explore these specific levels and how they are defined by ISTQB® because you have to know this for the exam if you choose to take it. But be aware that I will also give you several widely used alternative definitions of those levels that are practiced in the real world.

 ### All Levels in under 90 Seconds
Let me try and explain all of the test levels in under 90 seconds in a very simple way and then provide you with a sample system. 
I will then ask you to keep that in mind as we go through the rest of the module, talking about details. 

So here goes. Software is built from multiple components and at multiple layers.
 You identify the smallest possible unit, and you test that unit in isolation, trying to find and fix defects in that component alone.
  You do that for each component separately. 
  Then comes integration testing. You start connecting these components together. Units might work fine on their own, but they might fail when connected. Ideally, you should do this incrementally. Connect two units, test, then integrate a third, test, then the rest one by one. 
  
  System testing starts when everything or almost everything is in place, and you try to exercise the software from start to finish, and you do that using from the outside, which often involves an interface. Finally comes acceptance testing. The software is given to the end user, the customer, or their representative, and they should work with the software so that they can say, yes, this works as I wanted. I accept.
  
   All of these levels have common and specific objectives. The common ones include reducing risk; verifying functional and nonfunctional behaviors, and we'll talk about test types in the next module; build confidence in the system; find defects, obviously; but also for components and integration levels, we want to prevent them from escaping to higher levels because finding and fixing a bug in lower levels is faster and easier. Okay, so that was a high‑level overview, but I skipped a lot of detail, and now I will be talking about these details for the rest of this module. Let me just introduce you to a fictional banking system. This system provides a user interface through which you can do all sorts of things, check your current balance, check your savings account, transfer money into the savings account, play around with a mortgage calculator if you want to apply for one, as well as life and travel insurance calculators, all backed up by a common calculator module, providing basic math functions like adding and multiplying. And finally, there's a pretty good chance that all of your personal data is stored in a database. That's good enough for a fictional system, and we'll use it as we explore the test levels.


### Component Level
Component testing, also known as unit or module testing, focuses on components that are separately testable. Notice that, according to this definition, all three terms are synonymous. This is how ISTQB defines it, and this is what you should remember for the exam, but I'd say that there's a 99% chance that this is not how people understand it in the real world. 

The main source of confusion here is the difficulty of exactly defining the word unit. It is something very small that can be tested independently and in isolation, but how small can you go? Suppose you have a single code function that adds up two numbers, and it gives you the sum. Is this a unit? If you ask a developer, the answer will definitely be yes. And this can be tested. You can write multiple automated unit tests that verify it works correctly. But this function will be located in a source file, together with other small, logically‑related functions. We can have a file called Calculator, and it will have functions, add, subtract, multiply, divide. So we could also say that this one file is a unit. It's a bigger unit, but it's a unit nonetheless. Finally, we could have a small component called Mortgage Calculator, and we know that internally it consists of multiple files. So can we call this a single logical unit? 

So double‑check how you and your team define terms unit and module. Developers will tend to define it as a piece of code or a single source file at most, whereas testers, who don't see such low‑level details, might refer to a single logical business functionality. 

Consequently, the test basis and the approach will vary too. For developers, the test basis will be code itself, tech design, and perhaps a data model. And they can do either static testing, meaning just reading code and trying to find mistakes in code, or writing unit tests that exercise the separate functions and ensuring that they produce correct output. However, as I said, the terms are fluid, and if you are a tester and you have been tasked with component testing without looking at the code then your test basis will be the component spec, an outline telling you how exactly the calculation is supposed to happen.

 The main objective of unit testing is to find defects in that single component. Sounds obvious, but many still ignore the value such testing can bring. Imagine looking for a needle in a haystack. The needle is a software bug. It might take ages to find, but doing unit‑level testing is like providing your team with a method that tells you, hey, I don't know where exactly the defect is, but I'm pretty sure it's in this small region over here, so concentrate your effort on this area.